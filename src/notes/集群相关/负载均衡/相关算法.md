### 一致性 hash 算法

先说普通 hash 算法，简单来说就是通过 hash 取模算法将每个数据请求都均匀的分散到了三个不同的服务器节点上，这没问题；关键是如果后端服务器数量发生变化，比如多了1台或者少了一台，那所有的请求（缓存）都需要重新计算调整，会造成缓存的雪崩，最终导致整个缓存系统的不可用。

一致性哈希(Consistent Hash)算法目的是解决分布式系统的数据分区问题：当分布式集群移除或者添加一个服务器时，必须尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。

一致性哈希算法是对固定值 2^32 取模，这就使得一致性算法具备良好的单调性：不管集群中有多少个节点，只要key值固定，那所请求的服务器节点也同样是固定的。其算法的工作原理如下：

1. 一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为 0~2^32-1；
2. 计算各服务器节点的哈希值，并映射到哈希环上；
3. 将服务发来的数据请求使用哈希算法算出对应的哈希值；
4. 将计算的哈希值映射到哈希环上，同时沿圆环顺时针方向查找，遇到的第一台服务器就是所对应的处理请求服务器。
5. 当增加或者删除一台服务器时，受影响的数据仅仅是新添加或删除的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。

![image-20241012161147475](%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95.assets/image-20241012161147475.png)



综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性 

参考

https://blog.csdn.net/a745233700/article/details/120814088

https://developer.aliyun.com/article/1082388



### 加权轮询算法

加权轮询算法要生成一个服务器序列，该序列中包含 n 个服务器。n 是所有服务器的权重之和。在该序列中，每个

服务器的出现的次数，等于其权重值

普通加权轮询





平滑加权轮询

该算法的原理如下：

每个服务器都有两个权重变量：

　　a：weight，配置文件中指定的该服务器的权重，这个值是固定不变的；

　　b：current_weight，服务器目前的权重。一开始为0，之后会动态调整。

每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的 current_weight 增加它的

weight；同时累加所有服务器的 weight ，并保存为 total。

遍历完所有服务器之后，如果该服务器的 current_weight 是最大的，就选择这个服务器处理本次请求。最后把该服务器的 current_weight 减去total。

示例：

针对这样的配置

```
http {  
    upstream cluster {  
        server a weight=4;  
        server b weight=2;  
        server c weight=1;  
    }  
    ...
} 
```



按照这个配置，每 7 个客户端请求中，a 会被选中 4 次、b 会被选中 2 次、c会被选中 1 次，且分布平滑。我们来算算看是不是这样子的。

　　initial  current_weight  of a, b, c is {0, 0, 0}

![image-20241012163807286](%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95.assets/image-20241012163807286.png)

　　通过上述过程，可得以下结论：

　　a：7 个请求中，a、b、c 分别被选取了 4、2、1次，符合它们的权重值。

　　b：7 个请求中，a、b、c 被选取的顺序为 a, b,a, c, a, b, a，分布均匀，权重大的后端 a 没有被连续选取。

　　c：每经过 7 个请求后，a、b、c 的 current_weight 又回到初始值{0, 0,0}，因此上述流程是不断循环的。






参考

https://blog.csdn.net/gqtcgq/article/details/52076997