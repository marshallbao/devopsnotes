# I/O和mmap



### 关于缓存

1. #### 内核缓存（内核空间的页缓存）

- **所在位置**：内核空间
- **类型**：页缓存（page cache）
- 关键点：
  - 该缓存对所有进程共享
  - 它是内核维护的全局缓存
  - 典型命令 `free` 中的“cached”显示的是页缓存大小

2. #### 用户缓存（用户空间缓存）

- **所在位置**：用户空间（进程虚拟地址空间）
- 类型：
  - 应用层自己的缓存实现（例如 C 标准库的 stdio 缓冲，如 `fread()`, `fwrite()` 使用的缓冲区）
  - 程序内部的数据缓存，比如某些应用层的内存缓存策略
- 关键点：
  - 是每个进程私有的
  - 你可以通过设置缓冲模式 (`setvbuf()`等) 和大小，调整其行为



### 传统 I/O 和 mmap 对比

传统 I/O：磁盘 → 内核缓存 → 用户缓存 → 程序处理

mmap：磁盘 → 内核缓存 → 用户虚拟地址（直接映射）

#### 传统 read() 调用的数据流动：

1. 磁盘数据读到 **内核缓存**（页缓存）；
2. 内核通过系统调用将数据从内核缓存拷贝到 **用户空间缓冲区**（用户虚拟地址，调用栈或堆中的缓冲区）；
3. 应用程序从用户缓冲区中使用数据。

这里发生了一次 **内核空间到用户空间的内存拷贝**。

#### mmap 的数据流动：

1. 磁盘数据先读入 **内核缓存**（页缓存）；
2. 内核将对应内核缓存（页缓存）的物理页直接映射到用户进程的 **用户虚拟地址空间**（通过内存映射页表）；
3. 应用程序访问这个用户虚拟地址，实际是访问同一份物理内存数据，**无须额外拷贝**。
4. 

#### 为什么说 mmap 少了一次拷贝？

-  传统 read() 调用，你的数据必须经过内核空间和用户空间两次拷贝：
  - 磁盘 → 内核缓存（通过 I/O 设备 DMA，物理页拷贝）
  - 内核缓存 → 用户空间缓冲区（通过内存拷贝）
-  mmap 则是：
  - 磁盘 → 内核缓存（通过 I/O 设备 DMA，物理页拷贝，这个是必须的）
  - 用户空间虚拟地址直接映射到该内核缓存页，**访问时不再发生内核到用户空间的内存拷贝**

也就是说 mmap 避免了**第 2 步从内核缓存到用户空间拷贝的那次内存复制**。