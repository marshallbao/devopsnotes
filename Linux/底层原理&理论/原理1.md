### linux rm原理

很多时候，我 们都会发现，某个进程在对当前文件读写，但是我们依然能够rm， 是不是很奇怪？而windows下面，肯定会报错，”当前文件正在被使用“， 这就得从linux下面删除文件的原理说起了。

Linux是通过link的数量来控制文件删除的，只有当一个文件不存在任何link的时候，这个文件才会被删除。一般来说，每个文件都有2个link计数器:i_count 和 i_nlink。

i_count的意义是当前文件使用者（或被调用）的数量,i_nlink 的意义是介质连接的数量（硬链接的数量）；可以理解为i_count是内存引用计数器，i_nlink是磁盘的引用计数器。
当一个文件被某一个进程引用时，对应i_count数就会增加；当创建文件的硬链接的时候，对应i_nlink数就会增加。

对于删除命令rm而言，实际就是减少磁盘引用计数i_nlink。这里就会有一个问题，如果一个文件正在被某个进程调用，而用户却执行rm操作把文件删除了，那么会出现什么结果呢？当用户执行rm操作删除文件后，再执行ls或者其他文件管理命令，无法再找到这个文件了，但是调用这个删除的文件的进程却在继续正常执行，依然能够从文件中正确的读取及写入内容。这又是为什么呢？

这是因为rm操作只是将文件的i_nlink减少了，如果没其它的链接i_nlink就为0了；但由于该文件依然被进程引用，因此，此时文件对应的i_count并不为0，所以即使执行rm操作，但系统并没有真正删除这个文件，当只有i_nlink及i_count都为0的时候，这个文件才会真正被删除。也就是说，还需要解除该进程的对该文件的调用才行。

以上讲的i_nlink及i_count是文件删除的真实条件，但是当文件没有被调用时，执行了rm操作删除文件后是否还可以找回被删的文件呢？

前面说了，rm操作只是将文件的i_nlink减少了，或者说置0了，实际就是将文件名到inode的链接删除了，此时，并没有删除文件的实体即（block数据块），此时，如果及时停止机器工作，数据是可以找回的，如果此时继续写入数据，那么当新数据就可能会被分配到被删除的数据的block数据块，此时，文件就会被真正的回收了

备注：根据以上原理，实际情况会出现以下问题，web服务器磁盘空间不够了，删除了所有无用日志还是先是磁盘空间不足，但是用du -sh /*发现磁盘空间占用的远小于硬盘总大小，这就是因为只删除了一个i_nlink，而还有其他进程在使用着这些log文件，apache或者tomcat，重启再看就ok了。




sh bash 
\1. sh一般设成bash的软链
\2. 在一般的linux系统当中（如redhat），使用sh调用执行脚本相当于打开了bash的POSIX标准模式
\3. 也就是说 /bin/sh 相当于 /bin/bash --posix
bash 选项：
 -n 只读取shell脚本，但不实际执行
 -x 进入跟踪方式，显示所执行的每一条命令
 -c "string" 从strings中读取命令


./test.sh sh ./test.sh bash ./test.sh 都是创建子shell来执行脚本，可以继承父shell的变量，但子shell的变量无法传给父shell执行；（其他方法可以，但不了解）
source test.sh   . test.sh  是在当前父shell中执行此脚本


./test.sh sh ./test.sh bash ./test.sh 其中./test.sh 运行脚本，必须具有执行权限，这样才能读取到用哪种解释器解释此脚本如#!/bin/bash #!/user/bin/expect；
bash ./test.sh sh ./test.sh 是指定sh 来解释此脚本；
传子不传父 