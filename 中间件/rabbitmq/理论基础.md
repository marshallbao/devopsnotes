### RabbitMq 原理概念

#### 一、简介

MQ 全称为 Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队

列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发

送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应

用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM 

WEBSPHERE MQ等等

#### 二、使用场景

在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服

务器的请求响应时间，从而提高了系统的吞吐量。

#### 三、基本概念

1、Producer（生产者）

生产者是发送消息的应用程序。生产者将消息发送到 RabbitMQ 交换机（Exchange）。

2、Consumer（消费者）

消费者是接收消息的应用程序。消费者从 RabbitMQ 队列（Queue）中接收消息。

3、Queue（队列）

Queue 是 RabbitMQ 的内部对象，用于存储消息，用下图表示。

队列是 RabbitMQ 中存储消息的地方。消息从生产者发送到队列，消费者从队列中接收消息。

多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费

者都收到所有的消息并处理。

4、Exchange（交换机）

交换机接收生产者发送的消息，并根据绑定规则将消息路由到一个或多个队列。交换机有不同的类型：

- **Direct Exchange**：根据消息的路由键精确匹配队列。
- **Fanout Exchange**：将消息广播到所有绑定的队列。
- **Topic Exchange**：根据消息的路由键模式匹配队列。
- **Headers Exchange**：根据消息头属性匹配队列。

5、Binding（绑定）

绑定是交换机与队列之间的链接。绑定规则决定了消息如何从交换机路由到队列。

6、Message（消息）

消息是生产者发送到队列的数据单元，包含消息体和消息属性。

7、Virtual Host（虚拟主机）

虚拟主机是 RabbitMQ 中的多租户机制，用于隔离不同的应用程序和用户。每个虚拟主机可以有自己的队列、交换机、绑定等。

8、Connection（连接）

连接是生产者或消费者与 RabbitMQ 服务器之间的 TCP 连接。

9、Channel（信道）

信道是一个虚拟连接，建立在一个 TCP 连接之上。大多数操作（如声明队列、发布消息）都是在信道上完成的。

Channel 是 RabbitMQ 中的一个虚拟连接，它建立在一个实际的 TCP 连接之上。一个 TCP 连接可以包含多个 Channel，Channel 是进行消息传递的主要通信机制。

作用和优点

1. **资源节约**：创建和管理 TCP 连接相对较重，而 Channel 是轻量级的，能够减少资源的消耗。一个客户端可以通过单个 TCP 连接创建多个 Channel，从而节省资源。
2. **并发处理**：通过在一个 TCP 连接上创建多个 Channel，客户端可以并发地处理多个任务。例如，一个 Channel 可以用于发布消息，另一个 Channel 可以用于消费消息。
3. **隔离**：不同的 Channel 之间是隔离的，操作一个 Channel 不会影响其他 Channel。这种隔离性有助于提高系统的稳定性和安全性。

10、Routing Key

Routing Key 是 RabbitMQ 中用于消息路由的一个属性。生产者在发送消息时，可以指定一个 Routing Key，

RabbitMQ 根据这个 Routing Key 和交换机（Exchange）的类型，将消息路由到相应的队列（Queue）。同时当

声明 binding （即交换机绑定队列）时，也指定了一个 Routing key（binding key）,这时它的作用是定义交换机

如何将消息路由到队列。

Binding Key 和 Routing Key 的区别

- **定义和用途**：
  - **Binding Key**：用于在绑定交换机和队列时指定路由规则。它定义了交换机如何将消息路由到队列。
  - **Routing Key**：生产者在发送消息时指定的属性。它用于交换机在路由消息时进行匹配。
- **使用场景**：
  - **Binding Key**：在绑定操作中使用，连接交换机和队列，并指定消息的路由规则。
  - **Routing Key**：在发送消息时使用，告诉交换机如何将消息路由到合适的队列。
- **匹配规则**：
  - **Direct Exchange**：交换机会根据消息的 `Routing Key` 精确匹配 `Binding Key`。
  - **Topic Exchange**：交换机会根据消息的 `Routing Key` 模式匹配 `Binding Key`，支持通配符（如 `*` 和 `#`）。
  - **Fanout Exchange**：忽略 `Routing Key`，将消息广播到所有绑定的队列。
  - **Headers Exchange**：忽略 `Routing Key`，基于消息头属性进行路由。

#### 四、其他概念

Message acknowledgment

在实际应用中，可能会发生消费者收到 Queue 中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这

种种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给

RabbitMQ，RabbitMQ 收到消息回执（Message acknowledgment）后才将该消息从Queue中移除；如果

RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开，则RabbitMQ会将该消息发送给其他消费者（如

果存在多个消费者）进行处理。这里不存在timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送

给其他消费者，除非它的RabbitMQ连接断开。

这里会产生另外一个问题，如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严

重的bug——Queue中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执行业务逻辑…

另外pub message是没有ack的。

Message durability

如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可

持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。但依然解决不了小概率丢

失事件的发生（比如RabbitMQ服务器已经接收到生产者的消息，但还没来得及持久化该消息时RabbitMQ服务器

就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务。由于这里仅为RabbitMQ的简

单介绍，所以这里将不讲解RabbitMQ相关的事务。

Prefetch count

前面我们讲到如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时

如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并

一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置

prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发

送一条消息。

#### 五、权限及用户管理

用户标签（User Tags）

RabbitMQ 提供了几种预定义的用户标签，每种标签赋予用户不同的权限和作用。常见的用户标签包括：

1. **administrator**
   - **权限**：具有最高权限，可以执行所有管理操作。
   - **作用**：可以创建和删除用户、虚拟主机、权限、策略等。可以查看和管理所有的 RabbitMQ 配置和状态。
2. **monitoring**
   - **权限**：具有监控权限，但不能进行管理操作。
   - **作用**：可以查看 RabbitMQ 的状态、节点、连接、通道、队列、交换机等的统计信息。适用于需要监控系统但不需要进行配置更改的用户。
3. **management**
   - **权限**：具有管理插件的访问权限。
   - **作用**：可以访问和使用 RabbitMQ 的管理插件（如 RabbitMQ Management UI），但不能创建或删除用户、虚拟主机等。
4. **policymaker**
   - **权限**：可以查看和管理策略（policies）。
   - **作用**：可以创建、修改和删除策略。策略用于对队列和交换机应用特定的配置，如镜像队列、TTL 等。
5. **none**
   - **权限**：没有任何特殊权限。
   - **作用**：普通用户，没有管理权限。只能访问和操作其有权限的虚拟主机内的资源。

一般 administrator 、none 、monitoring 这几种比较常用

虚拟主机（vhost）权限

1. **configure**
   - **作用**：控制用户是否可以声明和删除交换机和队列。配置权限决定了用户能否创建、修改和删除 RabbitMQ 对象（如队列、交换机、绑定）。
   - **示例**：`"^amq."` 表示用户可以配置以 `amq.` 开头的资源。
2. **write**
   - **作用**：控制用户是否可以向交换机发布消息。写权限决定了用户能否向队列和交换机发送消息。
   - **示例**：`"^logs.*"` 表示用户可以向以 `logs.` 开头的交换机发送消息。
3. **read**
   - **作用**：控制用户是否可以从队列中获取消息。读权限决定了用户能否从队列中消费消息。
   - **示例**：`"^task_queue$"` 表示用户可以从名为 `task_queue` 的队列中消费消息。



### 参考

https://zhuanlan.zhihu.com/p/554203671